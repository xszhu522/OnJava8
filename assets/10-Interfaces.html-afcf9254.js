const e=JSON.parse('{"key":"v-75f32e84","path":"/book/10-Interfaces.html","title":"第十章 接口","lang":"zh-CN","frontmatter":{"description":"[TOC] 接口和抽象类提供了一种将接口与实现分离的更加结构化的方法。 这种机制在编程语言中不常见，例如 C++ 只对这种概念有间接的支持。而在 Java 中存在这些关键字，说明这些思想很重要，Java 为它们提供了直接支持。 首先，我们将学习抽象类，一种介于普通类和接口之间的折中手段。尽管你的第一想法是创建接口，但是对于构建具有属性和未实现方法的类来...","head":[["meta",{"property":"og:url","content":"https://xszhu522.github.io/OnJava8/book/10-Interfaces.html"}],["meta",{"property":"og:site_name","content":"On Java 8"}],["meta",{"property":"og:title","content":"第十章 接口"}],["meta",{"property":"og:description","content":"[TOC] 接口和抽象类提供了一种将接口与实现分离的更加结构化的方法。 这种机制在编程语言中不常见，例如 C++ 只对这种概念有间接的支持。而在 Java 中存在这些关键字，说明这些思想很重要，Java 为它们提供了直接支持。 首先，我们将学习抽象类，一种介于普通类和接口之间的折中手段。尽管你的第一想法是创建接口，但是对于构建具有属性和未实现方法的类来..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2020-12-01T04:55:39.000Z"}],["meta",{"property":"article:author","content":"xszhu522"}],["meta",{"property":"article:modified_time","content":"2020-12-01T04:55:39.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"第十章 接口\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2020-12-01T04:55:39.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"xszhu522\\",\\"url\\":\\"https://xszhu522.github.io\\"}]}"]]},"headers":[{"level":2,"title":"抽象类和方法","slug":"抽象类和方法","link":"#抽象类和方法","children":[]},{"level":2,"title":"接口创建","slug":"接口创建","link":"#接口创建","children":[{"level":3,"title":"默认方法","slug":"默认方法","link":"#默认方法","children":[]},{"level":3,"title":"多继承","slug":"多继承","link":"#多继承","children":[]},{"level":3,"title":"接口中的静态方法","slug":"接口中的静态方法","link":"#接口中的静态方法","children":[]},{"level":3,"title":"Instrument 作为接口","slug":"instrument-作为接口","link":"#instrument-作为接口","children":[]}]},{"level":2,"title":"抽象类和接口","slug":"抽象类和接口","link":"#抽象类和接口","children":[]},{"level":2,"title":"完全解耦","slug":"完全解耦","link":"#完全解耦","children":[]},{"level":2,"title":"多接口结合","slug":"多接口结合","link":"#多接口结合","children":[]},{"level":2,"title":"使用继承扩展接口","slug":"使用继承扩展接口","link":"#使用继承扩展接口","children":[{"level":3,"title":"结合接口时的命名冲突","slug":"结合接口时的命名冲突","link":"#结合接口时的命名冲突","children":[]}]},{"level":2,"title":"接口适配","slug":"接口适配","link":"#接口适配","children":[]},{"level":2,"title":"接口字段","slug":"接口字段","link":"#接口字段","children":[{"level":3,"title":"初始化接口中的字段","slug":"初始化接口中的字段","link":"#初始化接口中的字段","children":[]}]},{"level":2,"title":"接口嵌套","slug":"接口嵌套","link":"#接口嵌套","children":[]},{"level":2,"title":"接口和工厂方法模式","slug":"接口和工厂方法模式","link":"#接口和工厂方法模式","children":[]},{"level":2,"title":"本章小结","slug":"本章小结","link":"#本章小结","children":[]}],"git":{"createdTime":1553949104000,"updatedTime":1606798539000,"contributors":[{"name":"Joe","email":"736777445@qq.com","commits":5},{"name":"xiangflight","email":"xiangflight@foxmail.com","commits":4},{"name":"WangHengwei","email":"35023376@qq.com","commits":3},{"name":"andyphone","email":"792998301@qq.com","commits":3},{"name":"LingCoder","email":"lingcoder@gmail.com","commits":2},{"name":"qurrer","email":"40011809+qurrer@users.noreply.github.com","commits":1},{"name":"tangzhentao","email":"itangzhentao@126.com","commits":1},{"name":"yanxueer","email":"1164313233@qq.com","commits":1}]},"readingTime":{"minutes":34.35,"words":10306},"filePathRelative":"book/10-Interfaces.md","localizedDate":"2019年3月30日","autoDesc":true,"excerpt":""}');export{e as data};
