const l=JSON.parse('{"key":"v-3273e87b","path":"/book/20-Generics.html","title":"第二十章 泛型","lang":"zh-CN","frontmatter":{"description":"[TOC] 普通的类和方法只能使用特定的类型：基本数据类型或类类型。如果编写的代码需要应用于多种类型，这种严苛的限制对代码的束缚就会很大。 多态是一种面向对象思想的泛化机制。你可以将方法的参数类型设为基类，这样的方法就可以接受任何派生类作为参数，包括暂时还不存在的类。这样的方法更通用，应用范围更广。在类内部也是如此，在任何使用特定类型的地方，基类意味着...","head":[["meta",{"property":"og:url","content":"https://xszhu522.github.io/OnJava8/book/20-Generics.html"}],["meta",{"property":"og:site_name","content":"On Java 8"}],["meta",{"property":"og:title","content":"第二十章 泛型"}],["meta",{"property":"og:description","content":"[TOC] 普通的类和方法只能使用特定的类型：基本数据类型或类类型。如果编写的代码需要应用于多种类型，这种严苛的限制对代码的束缚就会很大。 多态是一种面向对象思想的泛化机制。你可以将方法的参数类型设为基类，这样的方法就可以接受任何派生类作为参数，包括暂时还不存在的类。这样的方法更通用，应用范围更广。在类内部也是如此，在任何使用特定类型的地方，基类意味着..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2020-12-14T07:36:11.000Z"}],["meta",{"property":"article:author","content":"xszhu522"}],["meta",{"property":"article:modified_time","content":"2020-12-14T07:36:11.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"第二十章 泛型\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2020-12-14T07:36:11.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"xszhu522\\",\\"url\\":\\"https://xszhu522.github.io\\"}]}"]]},"headers":[{"level":3,"title":"与 C++ 的比较","slug":"与-c-的比较","link":"#与-c-的比较","children":[]},{"level":2,"title":"简单泛型","slug":"简单泛型","link":"#简单泛型","children":[{"level":3,"title":"一个元组类库","slug":"一个元组类库","link":"#一个元组类库","children":[]},{"level":3,"title":"一个堆栈类","slug":"一个堆栈类","link":"#一个堆栈类","children":[]},{"level":3,"title":"RandomList","slug":"randomlist","link":"#randomlist","children":[]}]},{"level":2,"title":"泛型接口","slug":"泛型接口","link":"#泛型接口","children":[]},{"level":2,"title":"泛型方法","slug":"泛型方法","link":"#泛型方法","children":[{"level":3,"title":"变长参数和泛型方法","slug":"变长参数和泛型方法","link":"#变长参数和泛型方法","children":[]},{"level":3,"title":"一个泛型的 Supplier","slug":"一个泛型的-supplier","link":"#一个泛型的-supplier","children":[]},{"level":3,"title":"简化元组的使用","slug":"简化元组的使用","link":"#简化元组的使用","children":[]},{"level":3,"title":"一个 Set 工具","slug":"一个-set-工具","link":"#一个-set-工具","children":[]}]},{"level":2,"title":"构建复杂模型","slug":"构建复杂模型","link":"#构建复杂模型","children":[]},{"level":2,"title":"泛型擦除","slug":"泛型擦除","link":"#泛型擦除","children":[{"level":3,"title":"C++ 的方式","slug":"c-的方式","link":"#c-的方式","children":[]},{"level":3,"title":"迁移兼容性","slug":"迁移兼容性","link":"#迁移兼容性","children":[]},{"level":3,"title":"擦除的问题","slug":"擦除的问题","link":"#擦除的问题","children":[]},{"level":3,"title":"边界处的动作","slug":"边界处的动作","link":"#边界处的动作","children":[]}]},{"level":2,"title":"补偿擦除","slug":"补偿擦除","link":"#补偿擦除","children":[{"level":3,"title":"创建类型的实例","slug":"创建类型的实例","link":"#创建类型的实例","children":[]},{"level":3,"title":"泛型数组","slug":"泛型数组","link":"#泛型数组","children":[]}]},{"level":2,"title":"边界","slug":"边界","link":"#边界","children":[]},{"level":2,"title":"通配符","slug":"通配符","link":"#通配符","children":[{"level":3,"title":"编译器有多聪明","slug":"编译器有多聪明","link":"#编译器有多聪明","children":[]},{"level":3,"title":"逆变","slug":"逆变","link":"#逆变","children":[]},{"level":3,"title":"无界通配符","slug":"无界通配符","link":"#无界通配符","children":[]},{"level":3,"title":"捕获转换","slug":"捕获转换","link":"#捕获转换","children":[]}]},{"level":2,"title":"问题","slug":"问题","link":"#问题","children":[{"level":3,"title":"任何基本类型都不能作为类型参数","slug":"任何基本类型都不能作为类型参数","link":"#任何基本类型都不能作为类型参数","children":[]},{"level":3,"title":"实现参数化接口","slug":"实现参数化接口","link":"#实现参数化接口","children":[]},{"level":3,"title":"转型和警告","slug":"转型和警告","link":"#转型和警告","children":[]},{"level":3,"title":"重载","slug":"重载","link":"#重载","children":[]},{"level":3,"title":"基类劫持接口","slug":"基类劫持接口","link":"#基类劫持接口","children":[]}]},{"level":2,"title":"自限定的类型","slug":"自限定的类型","link":"#自限定的类型","children":[{"level":3,"title":"古怪的循环泛型","slug":"古怪的循环泛型","link":"#古怪的循环泛型","children":[]},{"level":3,"title":"自限定","slug":"自限定","link":"#自限定","children":[]},{"level":3,"title":"参数协变","slug":"参数协变","link":"#参数协变","children":[]}]},{"level":2,"title":"动态类型安全","slug":"动态类型安全","link":"#动态类型安全","children":[]},{"level":2,"title":"泛型异常","slug":"泛型异常","link":"#泛型异常","children":[]},{"level":2,"title":"混型","slug":"混型","link":"#混型","children":[{"level":3,"title":"C++ 中的混型","slug":"c-中的混型","link":"#c-中的混型","children":[]},{"level":3,"title":"与接口混合","slug":"与接口混合","link":"#与接口混合","children":[]},{"level":3,"title":"使用装饰器模式","slug":"使用装饰器模式","link":"#使用装饰器模式","children":[]},{"level":3,"title":"与动态代理混合","slug":"与动态代理混合","link":"#与动态代理混合","children":[]}]},{"level":2,"title":"潜在类型机制","slug":"潜在类型机制","link":"#潜在类型机制","children":[{"level":3,"title":"pyhton 中的潜在类型","slug":"pyhton-中的潜在类型","link":"#pyhton-中的潜在类型","children":[]},{"level":3,"title":"C++ 中的潜在类型","slug":"c-中的潜在类型","link":"#c-中的潜在类型","children":[]},{"level":3,"title":"Go 中的潜在类型","slug":"go-中的潜在类型","link":"#go-中的潜在类型","children":[]},{"level":3,"title":"java中的直接潜在类型","slug":"java中的直接潜在类型","link":"#java中的直接潜在类型","children":[]}]},{"level":2,"title":"对缺乏潜在类型机制的补偿","slug":"对缺乏潜在类型机制的补偿","link":"#对缺乏潜在类型机制的补偿","children":[{"level":3,"title":"反射","slug":"反射","link":"#反射","children":[]},{"level":3,"title":"将一个方法应用于序列","slug":"将一个方法应用于序列","link":"#将一个方法应用于序列","children":[]}]},{"level":2,"title":"Java8 中的辅助潜在类型","slug":"java8-中的辅助潜在类型","link":"#java8-中的辅助潜在类型","children":[{"level":3,"title":"使用Suppliers类的通用方法","slug":"使用suppliers类的通用方法","link":"#使用suppliers类的通用方法","children":[]}]},{"level":2,"title":"总结：类型转换真的如此之糟吗？","slug":"总结-类型转换真的如此之糟吗","link":"#总结-类型转换真的如此之糟吗","children":[]},{"level":2,"title":"进阶阅读","slug":"进阶阅读","link":"#进阶阅读","children":[]}],"git":{"createdTime":1553949104000,"updatedTime":1607931371000,"contributors":[{"name":"1326670425","email":"1326670425@qq.com","commits":5},{"name":"Michael Liu","email":"thinker1990@users.noreply.github.com","commits":5},{"name":"xiangflight","email":"xiangflight@foxmail.com","commits":5},{"name":"徐雁鑫","email":"funnycodingxu@gmail.com","commits":5},{"name":"siyuanzhou","email":"siyuanzhou@163..com","commits":4},{"name":"syzhou","email":"siyuanzhou@163.com","commits":4},{"name":"dellenovo","email":"zhanglifeifly@126.com","commits":2},{"name":"siyuanzhou","email":"siyuanzhou@163.com","commits":2},{"name":"FengBaoheng","email":"344092466@qq.com","commits":1},{"name":"FengBaoheng","email":"fengbaoheng@qq.com","commits":1},{"name":"Hao Lin","email":"1184264181@qq.com","commits":1},{"name":"Knn120","email":"19728079+Knn120@users.noreply.github.com","commits":1},{"name":"LingCoder","email":"lingcoder@gmail.com","commits":1},{"name":"YellowPixels","email":"zhangchi860804@163.com","commits":1},{"name":"gaodi16366","email":"44352537+gaodi16366@users.noreply.github.com","commits":1},{"name":"huakaimay","email":"39322023+nengquqiaoxiaoyun@users.noreply.github.com","commits":1},{"name":"xianwdong","email":"408050009@qq.com","commits":1}]},"readingTime":{"minutes":126.57,"words":37972},"filePathRelative":"book/20-Generics.md","localizedDate":"2019年3月30日","autoDesc":true,"excerpt":""}');export{l as data};
